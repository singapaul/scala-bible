# Basics 


We use classes just like in Java

a class organises data which is a representation of something

```
 class Person(name: String, val age: Int) {
    body
    val x = 2 //// we can use this value as it's a field of the object, even after vals are defined after it.
    var y = 3
    we can do anything in this block we'd do in a block expression

    We can add the below methods to the class as well. 

    **Below is an example of method overloading**
    def greet(name: String): Unit = println(s"${this.name} says: Hello $name")
    def greet(): Unit = println(s"Hi I am $name")

    The class comes with its own constructor. But we can add more. 
    See below with one constructor argument and one with none. 
    Below is an example of an **auxillary constructor**
    def this(name: String) = this(name, 0)
    def this() =    this("John Doe")



```

## Parameters vs fields

  age is a class parameter but not a field, cannot access by dot notation in order to get access to the age we need to add the keyword val in the class.
  
  To remedy this we need to add val which will turn the parameter -> field

In the above example we used this.name to access the name instance on this instance.

** Instantiating a class ** 

```
  val person = new Person("John", 2)
  println(person.age)
```

### Further class examples 

```
class Writer(firstName: String, surname: String,val year: Int){
  def fullName(): Unit = println(this.firstName + " " + this.surname)
}

class Novel(name: String, year: Int, author: Writer){

  def authorAge(): Unit = println(year - author.year)
  def isWrittenby(author: Writer) = author ==this.author
  def copy(newYear: Int): Novel = new Novel(name, newYear, author)


}


class Counter(val count: Int){
  def inc = new Counter(count + 1)  //immutable
  def dec = new Counter(count -1)

//recursive
  def inc(n: Int): Counter = {
  if (n<=0) this
  else inc.inc(n-1)
  }

```


# Case classes 

Problem: for lightweight classes we often need to retype alot of boiler plate code
  
  1. companion objects
  2. equals
  3. hashCode
  4. toString

  Case Classes are an ideal solution to this. Case classes let us define a class and a companion object in one go.

  They are simple to write but what does it do?

1. class parameters are promoted to fields
2. Results in a sensible toString
3. equals and hashCode are implemented out of the box
4. Case classes have handy copy methods.
5. Case classes have companion objects
6. Case classes are serializable - handy in AKKA (sending serializable messages through a network)
7. Case classes have extractor patterns. They can be used in pattern matching (powerful scala feature)


### 1. Fields 

```
  case class Person(name: String, age: Int)
  val jim= new Person("Jim", 34)
  //if it wasn't a case class we couldn't do this
println(jim.name)

```

### 2. toString method


```
  println(jim.toString) // (jim, 34), if not results in 34097349jdfhdsdkf238
  println(jim)
```

### 3. Equals comes out of the box

If we didn't have equals the below statements would point to different references and show false 

```
    val Jim2 = new Person("Jim", 34)
    println(jim == Jim2)
```

# 4. Copy

Copy creates a new instance of a case class. Copies receive parameters, so we can copy the class but only change one value if we want. 

```
  val jim3 = jim.copy(age = 45)
  println(jim3)
```

# 5. Companion object

Companion methods have handy factory methods.
The subtle difference is that we didn't use the word new as we instantiated the companion object.

```
    val thePerson = Person
    val mary = Person("Mary", 23)
```

# 6. pending
# 7. pending

----------------------------------------------------------------

## Can also create case objects 

See below example

```
  case object UnitedKingdom{
    def name: String = "The UK of GB and NI"
  }
```

# Case classes summarry 

  Quick lightweight data structures with little boilerplate
  Companions are already implemented
  sensible equals, hashcode and toString
  Allows for auto promotion of parameters to fields
  Allows for cloning
  Allows for case objects
