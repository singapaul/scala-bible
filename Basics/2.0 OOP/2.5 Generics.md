# Generics

We want to write collections that can store certain data types when we use them.
We can make these methods reusable by creating them with a type [T]

The add method will take a type B, which is a super type of A.
If to a list of A, I add a B, it will turn into a list of B

```
  class myList[+A]{
    will use the type A
def add[B >:A](element: B): myList[B] = ???

 A = CAT
 B = Animal
 So out list of cats will get turned into a list of animals which the addition of an animal
We do want variant problems
  }
```

## Variance problem

```
  class Animal
  class Cat extends Animal
  class Dog extends Animal
```

We have to ask: can a list of cats extend a list of Animals?

1. Yes = Covariance
2. No = Invariance
3. HELL NO = Contravariance

### Covariance

Yes List[Cat] extends List[Animal] = COVARIANCE

```
class CovariantList[+A]
  val animal: Animal = new Cat
  val animalList: CovariantList[Animal] = new CovariantList[Cat]
```
If we have a list of animals which is a list of cats and we add a dog to it, the list will become a list of animals. Adding a dog to a list of cats will make the list more generic.

### Invariance 

```
  class InvariantList[A]
  val invariantAnimalList: InvariantList[Animal] = new InvariantList[Animal]
```

### Contravariance

below makes sense, a trainer of animals could train a cat  opposite of covariance

```
class Trainer[-A]
val trainer: Trainer[Cat] = new Trainer[Animal]
```

## Bounded types 

Notes on this :> and :< I need to do some reading lol